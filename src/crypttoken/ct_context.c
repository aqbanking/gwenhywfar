/**********************************************************
 * This file has been automatically created by "typemaker2"
 * from the file "ct_context.xml".
 * Please do not edit this file, all changes will be lost.
 * Better edit the mentioned source file instead.
 **********************************************************/

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include "ct_context_p.h"

#include <gwenhywfar/misc.h>
#include <gwenhywfar/debug.h>

/* code headers */

/* macro functions */
GWEN_LIST_FUNCTIONS(GWEN_CRYPT_TOKEN_CONTEXT, GWEN_Crypt_Token_Context)
GWEN_LIST2_FUNCTIONS(GWEN_CRYPT_TOKEN_CONTEXT, GWEN_Crypt_Token_Context)
GWEN_INHERIT_FUNCTIONS(GWEN_CRYPT_TOKEN_CONTEXT)


GWEN_CRYPT_TOKEN_CONTEXT *GWEN_Crypt_Token_Context_new(void)
{
  GWEN_CRYPT_TOKEN_CONTEXT *p_struct;

  GWEN_NEW_OBJECT(GWEN_CRYPT_TOKEN_CONTEXT, p_struct)
  p_struct->_refCount = 1;
  GWEN_INHERIT_INIT(GWEN_CRYPT_TOKEN_CONTEXT, p_struct)
  GWEN_LIST_INIT(GWEN_CRYPT_TOKEN_CONTEXT, p_struct)
  /* members */
  p_struct->id = 0;
  p_struct->signKeyId = 0;
  p_struct->verifyKeyId = 0;
  p_struct->encipherKeyId = 0;
  p_struct->decipherKeyId = 0;
  p_struct->authSignKeyId = 0;
  p_struct->authVerifyKeyId = 0;
  p_struct->tempSignKeyId = 0;
  p_struct->keyHashNum = 0;
  p_struct->keyHashVer = 0;
  p_struct->keyHashAlgo = 0;
  p_struct->keyHash.pointer = NULL;
  p_struct->keyHash.length = 0;
  p_struct->keyStatus = 0;
  p_struct->protocolVersion = 0;
  p_struct->cid = NULL;
  p_struct->serviceId = NULL;
  p_struct->userId = NULL;
  p_struct->customerId = NULL;
  p_struct->userName = NULL;
  p_struct->peerId = NULL;
  p_struct->peerName = NULL;
  p_struct->address = NULL;
  p_struct->port = 0;
  p_struct->systemId = NULL;
  /* virtual functions */

  return p_struct;
}

void GWEN_Crypt_Token_Context_free(GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  if (p_struct) {
    assert(p_struct->_refCount);
    if (p_struct->_refCount == 1) {
      GWEN_INHERIT_FINI(GWEN_CRYPT_TOKEN_CONTEXT, p_struct)
      GWEN_LIST_FINI(GWEN_CRYPT_TOKEN_CONTEXT, p_struct)
      /* members */
      if (p_struct->keyHash.length && p_struct->keyHash.pointer) {
        free(p_struct->keyHash.pointer);
      }
      p_struct->keyHash.pointer = NULL;
      p_struct->keyHash.length = 0;
      free(p_struct->cid);
      p_struct->cid = NULL;
      free(p_struct->serviceId);
      p_struct->serviceId = NULL;
      free(p_struct->userId);
      p_struct->userId = NULL;
      free(p_struct->customerId);
      p_struct->customerId = NULL;
      free(p_struct->userName);
      p_struct->userName = NULL;
      free(p_struct->peerId);
      p_struct->peerId = NULL;
      free(p_struct->peerName);
      p_struct->peerName = NULL;
      free(p_struct->address);
      p_struct->address = NULL;
      free(p_struct->systemId);
      p_struct->systemId = NULL;
      p_struct->_refCount = 0;
      GWEN_FREE_OBJECT(p_struct);
    } else
      p_struct->_refCount--;
  }
}

void GWEN_Crypt_Token_Context_Attach(GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  assert(p_struct->_refCount);
  p_struct->_refCount++;
}

GWEN_CRYPT_TOKEN_CONTEXT *GWEN_Crypt_Token_Context_dup(const GWEN_CRYPT_TOKEN_CONTEXT *p_src)
{
  GWEN_CRYPT_TOKEN_CONTEXT *p_struct;

  assert(p_src);
  p_struct = GWEN_Crypt_Token_Context_new();
  /* member "id" */
  p_struct->id = p_src->id;

  /* member "signKeyId" */
  p_struct->signKeyId = p_src->signKeyId;

  /* member "verifyKeyId" */
  p_struct->verifyKeyId = p_src->verifyKeyId;

  /* member "encipherKeyId" */
  p_struct->encipherKeyId = p_src->encipherKeyId;

  /* member "decipherKeyId" */
  p_struct->decipherKeyId = p_src->decipherKeyId;

  /* member "authSignKeyId" */
  p_struct->authSignKeyId = p_src->authSignKeyId;

  /* member "authVerifyKeyId" */
  p_struct->authVerifyKeyId = p_src->authVerifyKeyId;

  /* member "tempSignKeyId" */
  p_struct->tempSignKeyId = p_src->tempSignKeyId;

  /* member "keyHashNum" */
  p_struct->keyHashNum = p_src->keyHashNum;

  /* member "keyHashVer" */
  p_struct->keyHashVer = p_src->keyHashVer;

  /* member "keyHashAlgo" */
  p_struct->keyHashAlgo = p_src->keyHashAlgo;

  /* member "keyHash" */
  if (p_src->keyHash.length && p_src->keyHash.pointer) {
    p_struct->keyHash.pointer = (uint8_t*) malloc(p_src->keyHash.length);
    if (p_struct->keyHash.pointer) {
      p_struct->keyHash.length = p_src->keyHash.length;
      memmove(p_struct->keyHash.pointer, p_src->keyHash.pointer, p_src->keyHash.length);
    } else {
      p_struct->keyHash.pointer = NULL;
      p_struct->keyHash.length = 0;
    }
  } else {
    p_struct->keyHash.pointer = NULL;
    p_struct->keyHash.length = 0;
  }

  /* member "keyStatus" */
  p_struct->keyStatus = p_src->keyStatus;

  /* member "protocolVersion" */
  p_struct->protocolVersion = p_src->protocolVersion;

  /* member "cid" */
  if (p_struct->cid) {
    free(p_struct->cid);
    p_struct->cid = NULL;
    p_struct->cid = NULL;
  }
  if (p_src->cid) {
    p_struct->cid = strdup(p_src->cid);
  }

  /* member "serviceId" */
  if (p_struct->serviceId) {
    free(p_struct->serviceId);
    p_struct->serviceId = NULL;
    p_struct->serviceId = NULL;
  }
  if (p_src->serviceId) {
    p_struct->serviceId = strdup(p_src->serviceId);
  }

  /* member "userId" */
  if (p_struct->userId) {
    free(p_struct->userId);
    p_struct->userId = NULL;
    p_struct->userId = NULL;
  }
  if (p_src->userId) {
    p_struct->userId = strdup(p_src->userId);
  }

  /* member "customerId" */
  if (p_struct->customerId) {
    free(p_struct->customerId);
    p_struct->customerId = NULL;
    p_struct->customerId = NULL;
  }
  if (p_src->customerId) {
    p_struct->customerId = strdup(p_src->customerId);
  }

  /* member "userName" */
  if (p_struct->userName) {
    free(p_struct->userName);
    p_struct->userName = NULL;
    p_struct->userName = NULL;
  }
  if (p_src->userName) {
    p_struct->userName = strdup(p_src->userName);
  }

  /* member "peerId" */
  if (p_struct->peerId) {
    free(p_struct->peerId);
    p_struct->peerId = NULL;
    p_struct->peerId = NULL;
  }
  if (p_src->peerId) {
    p_struct->peerId = strdup(p_src->peerId);
  }

  /* member "peerName" */
  if (p_struct->peerName) {
    free(p_struct->peerName);
    p_struct->peerName = NULL;
    p_struct->peerName = NULL;
  }
  if (p_src->peerName) {
    p_struct->peerName = strdup(p_src->peerName);
  }

  /* member "address" */
  if (p_struct->address) {
    free(p_struct->address);
    p_struct->address = NULL;
    p_struct->address = NULL;
  }
  if (p_src->address) {
    p_struct->address = strdup(p_src->address);
  }

  /* member "port" */
  p_struct->port = p_src->port;

  /* member "systemId" */
  if (p_struct->systemId) {
    free(p_struct->systemId);
    p_struct->systemId = NULL;
    p_struct->systemId = NULL;
  }
  if (p_src->systemId) {
    p_struct->systemId = strdup(p_src->systemId);
  }

  return p_struct;
}

GWEN_CRYPT_TOKEN_CONTEXT *GWEN_Crypt_Token_Context_copy(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, const GWEN_CRYPT_TOKEN_CONTEXT *p_src)
{
  assert(p_struct);
  assert(p_src);
  /* member "id" */
  p_struct->id = p_src->id;

  /* member "signKeyId" */
  p_struct->signKeyId = p_src->signKeyId;

  /* member "verifyKeyId" */
  p_struct->verifyKeyId = p_src->verifyKeyId;

  /* member "encipherKeyId" */
  p_struct->encipherKeyId = p_src->encipherKeyId;

  /* member "decipherKeyId" */
  p_struct->decipherKeyId = p_src->decipherKeyId;

  /* member "authSignKeyId" */
  p_struct->authSignKeyId = p_src->authSignKeyId;

  /* member "authVerifyKeyId" */
  p_struct->authVerifyKeyId = p_src->authVerifyKeyId;

  /* member "tempSignKeyId" */
  p_struct->tempSignKeyId = p_src->tempSignKeyId;

  /* member "keyHashNum" */
  p_struct->keyHashNum = p_src->keyHashNum;

  /* member "keyHashVer" */
  p_struct->keyHashVer = p_src->keyHashVer;

  /* member "keyHashAlgo" */
  p_struct->keyHashAlgo = p_src->keyHashAlgo;

  /* member "keyHash" */
  if (p_src->keyHash.length && p_src->keyHash.pointer) {
    p_struct->keyHash.pointer = (uint8_t*) malloc(p_src->keyHash.length);
    if (p_struct->keyHash.pointer) {
      p_struct->keyHash.length = p_src->keyHash.length;
      memmove(p_struct->keyHash.pointer, p_src->keyHash.pointer, p_src->keyHash.length);
    } else {
      p_struct->keyHash.pointer = NULL;
      p_struct->keyHash.length = 0;
    }
  } else {
    p_struct->keyHash.pointer = NULL;
    p_struct->keyHash.length = 0;
  }

  /* member "keyStatus" */
  p_struct->keyStatus = p_src->keyStatus;

  /* member "protocolVersion" */
  p_struct->protocolVersion = p_src->protocolVersion;

  /* member "cid" */
  if (p_struct->cid) {
    free(p_struct->cid);
    p_struct->cid = NULL;
    p_struct->cid = NULL;
  }
  if (p_src->cid) {
    p_struct->cid = strdup(p_src->cid);
  }

  /* member "serviceId" */
  if (p_struct->serviceId) {
    free(p_struct->serviceId);
    p_struct->serviceId = NULL;
    p_struct->serviceId = NULL;
  }
  if (p_src->serviceId) {
    p_struct->serviceId = strdup(p_src->serviceId);
  }

  /* member "userId" */
  if (p_struct->userId) {
    free(p_struct->userId);
    p_struct->userId = NULL;
    p_struct->userId = NULL;
  }
  if (p_src->userId) {
    p_struct->userId = strdup(p_src->userId);
  }

  /* member "customerId" */
  if (p_struct->customerId) {
    free(p_struct->customerId);
    p_struct->customerId = NULL;
    p_struct->customerId = NULL;
  }
  if (p_src->customerId) {
    p_struct->customerId = strdup(p_src->customerId);
  }

  /* member "userName" */
  if (p_struct->userName) {
    free(p_struct->userName);
    p_struct->userName = NULL;
    p_struct->userName = NULL;
  }
  if (p_src->userName) {
    p_struct->userName = strdup(p_src->userName);
  }

  /* member "peerId" */
  if (p_struct->peerId) {
    free(p_struct->peerId);
    p_struct->peerId = NULL;
    p_struct->peerId = NULL;
  }
  if (p_src->peerId) {
    p_struct->peerId = strdup(p_src->peerId);
  }

  /* member "peerName" */
  if (p_struct->peerName) {
    free(p_struct->peerName);
    p_struct->peerName = NULL;
    p_struct->peerName = NULL;
  }
  if (p_src->peerName) {
    p_struct->peerName = strdup(p_src->peerName);
  }

  /* member "address" */
  if (p_struct->address) {
    free(p_struct->address);
    p_struct->address = NULL;
    p_struct->address = NULL;
  }
  if (p_src->address) {
    p_struct->address = strdup(p_src->address);
  }

  /* member "port" */
  p_struct->port = p_src->port;

  /* member "systemId" */
  if (p_struct->systemId) {
    free(p_struct->systemId);
    p_struct->systemId = NULL;
    p_struct->systemId = NULL;
  }
  if (p_src->systemId) {
    p_struct->systemId = strdup(p_src->systemId);
  }

  return p_struct;
}

uint32_t GWEN_Crypt_Token_Context_GetId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->id;
}

uint32_t GWEN_Crypt_Token_Context_GetSignKeyId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->signKeyId;
}

uint32_t GWEN_Crypt_Token_Context_GetVerifyKeyId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->verifyKeyId;
}

uint32_t GWEN_Crypt_Token_Context_GetEncipherKeyId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->encipherKeyId;
}

uint32_t GWEN_Crypt_Token_Context_GetDecipherKeyId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->decipherKeyId;
}

uint32_t GWEN_Crypt_Token_Context_GetAuthSignKeyId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->authSignKeyId;
}

uint32_t GWEN_Crypt_Token_Context_GetAuthVerifyKeyId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->authVerifyKeyId;
}

uint32_t GWEN_Crypt_Token_Context_GetTempSignKeyId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->tempSignKeyId;
}

uint32_t GWEN_Crypt_Token_Context_GetKeyHashNum(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->keyHashNum;
}

uint32_t GWEN_Crypt_Token_Context_GetKeyHashVer(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->keyHashVer;
}

uint32_t GWEN_Crypt_Token_Context_GetKeyHashAlgo(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->keyHashAlgo;
}

uint32_t GWEN_Crypt_Token_Context_GetKeyStatus(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->keyStatus;
}

uint32_t GWEN_Crypt_Token_Context_GetProtocolVersion(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->protocolVersion;
}

const char *GWEN_Crypt_Token_Context_GetCid(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->cid;
}

const char *GWEN_Crypt_Token_Context_GetServiceId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->serviceId;
}

const char *GWEN_Crypt_Token_Context_GetUserId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->userId;
}

const char *GWEN_Crypt_Token_Context_GetCustomerId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->customerId;
}

const char *GWEN_Crypt_Token_Context_GetUserName(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->userName;
}

const char *GWEN_Crypt_Token_Context_GetPeerId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->peerId;
}

const char *GWEN_Crypt_Token_Context_GetPeerName(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->peerName;
}

const char *GWEN_Crypt_Token_Context_GetAddress(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->address;
}

int GWEN_Crypt_Token_Context_GetPort(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->port;
}

const char *GWEN_Crypt_Token_Context_GetSystemId(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct)
{
  assert(p_struct);
  return p_struct->systemId;
}

void GWEN_Crypt_Token_Context_SetId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->id = p_src;
}

void GWEN_Crypt_Token_Context_SetSignKeyId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->signKeyId = p_src;
}

void GWEN_Crypt_Token_Context_SetVerifyKeyId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->verifyKeyId = p_src;
}

void GWEN_Crypt_Token_Context_SetEncipherKeyId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->encipherKeyId = p_src;
}

void GWEN_Crypt_Token_Context_SetDecipherKeyId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->decipherKeyId = p_src;
}

void GWEN_Crypt_Token_Context_SetAuthSignKeyId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->authSignKeyId = p_src;
}

void GWEN_Crypt_Token_Context_SetAuthVerifyKeyId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->authVerifyKeyId = p_src;
}

void GWEN_Crypt_Token_Context_SetTempSignKeyId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->tempSignKeyId = p_src;
}

void GWEN_Crypt_Token_Context_SetKeyHashNum(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->keyHashNum = p_src;
}

void GWEN_Crypt_Token_Context_SetKeyHashVer(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->keyHashVer = p_src;
}

void GWEN_Crypt_Token_Context_SetKeyHashAlgo(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->keyHashAlgo = p_src;
}

void GWEN_Crypt_Token_Context_SetKeyStatus(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->keyStatus = p_src;
}

void GWEN_Crypt_Token_Context_SetProtocolVersion(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, uint32_t p_src)
{
  assert(p_struct);
  p_struct->protocolVersion = p_src;
}

void GWEN_Crypt_Token_Context_SetCid(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, const char *p_src)
{
  assert(p_struct);
  if (p_struct->cid) {
    free(p_struct->cid);
    p_struct->cid = NULL;
  }
  if (p_src) {
    p_struct->cid = strdup(p_src);
  } else {
    p_struct->cid = NULL;
  }
}

void GWEN_Crypt_Token_Context_SetServiceId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, const char *p_src)
{
  assert(p_struct);
  if (p_struct->serviceId) {
    free(p_struct->serviceId);
    p_struct->serviceId = NULL;
  }
  if (p_src) {
    p_struct->serviceId = strdup(p_src);
  } else {
    p_struct->serviceId = NULL;
  }
}

void GWEN_Crypt_Token_Context_SetUserId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, const char *p_src)
{
  assert(p_struct);
  if (p_struct->userId) {
    free(p_struct->userId);
    p_struct->userId = NULL;
  }
  if (p_src) {
    p_struct->userId = strdup(p_src);
  } else {
    p_struct->userId = NULL;
  }
}

void GWEN_Crypt_Token_Context_SetCustomerId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, const char *p_src)
{
  assert(p_struct);
  if (p_struct->customerId) {
    free(p_struct->customerId);
    p_struct->customerId = NULL;
  }
  if (p_src) {
    p_struct->customerId = strdup(p_src);
  } else {
    p_struct->customerId = NULL;
  }
}

void GWEN_Crypt_Token_Context_SetUserName(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, const char *p_src)
{
  assert(p_struct);
  if (p_struct->userName) {
    free(p_struct->userName);
    p_struct->userName = NULL;
  }
  if (p_src) {
    p_struct->userName = strdup(p_src);
  } else {
    p_struct->userName = NULL;
  }
}

void GWEN_Crypt_Token_Context_SetPeerId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, const char *p_src)
{
  assert(p_struct);
  if (p_struct->peerId) {
    free(p_struct->peerId);
    p_struct->peerId = NULL;
  }
  if (p_src) {
    p_struct->peerId = strdup(p_src);
  } else {
    p_struct->peerId = NULL;
  }
}

void GWEN_Crypt_Token_Context_SetPeerName(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, const char *p_src)
{
  assert(p_struct);
  if (p_struct->peerName) {
    free(p_struct->peerName);
    p_struct->peerName = NULL;
  }
  if (p_src) {
    p_struct->peerName = strdup(p_src);
  } else {
    p_struct->peerName = NULL;
  }
}

void GWEN_Crypt_Token_Context_SetAddress(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, const char *p_src)
{
  assert(p_struct);
  if (p_struct->address) {
    free(p_struct->address);
    p_struct->address = NULL;
  }
  if (p_src) {
    p_struct->address = strdup(p_src);
  } else {
    p_struct->address = NULL;
  }
}

void GWEN_Crypt_Token_Context_SetPort(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, int p_src)
{
  assert(p_struct);
  p_struct->port = p_src;
}

void GWEN_Crypt_Token_Context_SetSystemId(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, const char *p_src)
{
  assert(p_struct);
  if (p_struct->systemId) {
    free(p_struct->systemId);
    p_struct->systemId = NULL;
  }
  if (p_src) {
    p_struct->systemId = strdup(p_src);
  } else {
    p_struct->systemId = NULL;
  }
}

/* list1 functions */
GWEN_CRYPT_TOKEN_CONTEXT_LIST *GWEN_Crypt_Token_Context_List_dup(const GWEN_CRYPT_TOKEN_CONTEXT_LIST *p_src)
{
  GWEN_CRYPT_TOKEN_CONTEXT_LIST *p_dest;
  GWEN_CRYPT_TOKEN_CONTEXT *p_elem;

  assert(p_src);
  p_dest = GWEN_Crypt_Token_Context_List_new();
  p_elem = GWEN_Crypt_Token_Context_List_First(p_src);
  while(p_elem) {
    GWEN_CRYPT_TOKEN_CONTEXT *p_cpy;

    p_cpy = GWEN_Crypt_Token_Context_dup(p_elem);
    GWEN_Crypt_Token_Context_List_Add(p_cpy, p_dest);
    p_elem = GWEN_Crypt_Token_Context_List_Next(p_elem);
  }

  return p_dest;
}

void GWEN_Crypt_Token_Context_ReadDb(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, GWEN_DB_NODE *p_db)
{
  assert(p_struct);
  /* member "id" */
  p_struct->id = GWEN_DB_GetIntValue(p_db, "id", 0, 0);

  /* member "signKeyId" */
  p_struct->signKeyId = GWEN_DB_GetIntValue(p_db, "signKeyId", 0, 0);

  /* member "verifyKeyId" */
  p_struct->verifyKeyId = GWEN_DB_GetIntValue(p_db, "verifyKeyId", 0, 0);

  /* member "encipherKeyId" */
  p_struct->encipherKeyId = GWEN_DB_GetIntValue(p_db, "encipherKeyId", 0, 0);

  /* member "decipherKeyId" */
  p_struct->decipherKeyId = GWEN_DB_GetIntValue(p_db, "decipherKeyId", 0, 0);

  /* member "authSignKeyId" */
  p_struct->authSignKeyId = GWEN_DB_GetIntValue(p_db, "authSignKeyId", 0, 0);

  /* member "authVerifyKeyId" */
  p_struct->authVerifyKeyId = GWEN_DB_GetIntValue(p_db, "authVerifyKeyId", 0, 0);

  /* member "tempSignKeyId" */
  p_struct->tempSignKeyId = GWEN_DB_GetIntValue(p_db, "tempSignKeyId", 0, 0);

  /* member "keyHashNum" */
  p_struct->keyHashNum = GWEN_DB_GetIntValue(p_db, "keyHashNum", 0, 0);

  /* member "keyHashVer" */
  p_struct->keyHashVer = GWEN_DB_GetIntValue(p_db, "keyHashVer", 0, 0);

  /* member "keyHashAlgo" */
  p_struct->keyHashAlgo = GWEN_DB_GetIntValue(p_db, "keyHashAlgo", 0, 0);

  /* member "keyHash" */
  {
    const void *v;
    unsigned int vlen;
    v = GWEN_DB_GetBinValue(p_db, "keyHash", 0, NULL, 0, &vlen);
    if (v && vlen) {
      uint8_t *dest;
      dest = (uint8_t*) malloc(vlen);
      memmove(dest, v, vlen);
      p_struct->keyHash.pointer = dest;
      p_struct->keyHash.length = vlen;
    }
  }

  /* member "keyStatus" */
  p_struct->keyStatus = GWEN_DB_GetIntValue(p_db, "keyStatus", 0, 0);

  /* member "protocolVersion" */
  p_struct->protocolVersion = GWEN_DB_GetIntValue(p_db, "protocolVersion", 0, 0);

  /* member "cid" */
  if (p_struct->cid) {
    free(p_struct->cid);
    p_struct->cid = NULL;
  }
  {
    const char *s;
    s = GWEN_DB_GetCharValue(p_db, "cid", 0, NULL);
    if (s) p_struct->cid = strdup(s);
  }
  if (p_struct->cid == NULL) {
    p_struct->cid = NULL;
  }

  /* member "serviceId" */
  if (p_struct->serviceId) {
    free(p_struct->serviceId);
    p_struct->serviceId = NULL;
  }
  {
    const char *s;
    s = GWEN_DB_GetCharValue(p_db, "serviceId", 0, NULL);
    if (s) p_struct->serviceId = strdup(s);
  }
  if (p_struct->serviceId == NULL) {
    p_struct->serviceId = NULL;
  }

  /* member "userId" */
  if (p_struct->userId) {
    free(p_struct->userId);
    p_struct->userId = NULL;
  }
  {
    const char *s;
    s = GWEN_DB_GetCharValue(p_db, "userId", 0, NULL);
    if (s) p_struct->userId = strdup(s);
  }
  if (p_struct->userId == NULL) {
    p_struct->userId = NULL;
  }

  /* member "customerId" */
  if (p_struct->customerId) {
    free(p_struct->customerId);
    p_struct->customerId = NULL;
  }
  {
    const char *s;
    s = GWEN_DB_GetCharValue(p_db, "customerId", 0, NULL);
    if (s) p_struct->customerId = strdup(s);
  }
  if (p_struct->customerId == NULL) {
    p_struct->customerId = NULL;
  }

  /* member "userName" */
  if (p_struct->userName) {
    free(p_struct->userName);
    p_struct->userName = NULL;
  }
  {
    const char *s;
    s = GWEN_DB_GetCharValue(p_db, "userName", 0, NULL);
    if (s) p_struct->userName = strdup(s);
  }
  if (p_struct->userName == NULL) {
    p_struct->userName = NULL;
  }

  /* member "peerId" */
  if (p_struct->peerId) {
    free(p_struct->peerId);
    p_struct->peerId = NULL;
  }
  {
    const char *s;
    s = GWEN_DB_GetCharValue(p_db, "peerId", 0, NULL);
    if (s) p_struct->peerId = strdup(s);
  }
  if (p_struct->peerId == NULL) {
    p_struct->peerId = NULL;
  }

  /* member "peerName" */
  if (p_struct->peerName) {
    free(p_struct->peerName);
    p_struct->peerName = NULL;
  }
  {
    const char *s;
    s = GWEN_DB_GetCharValue(p_db, "peerName", 0, NULL);
    if (s) p_struct->peerName = strdup(s);
  }
  if (p_struct->peerName == NULL) {
    p_struct->peerName = NULL;
  }

  /* member "address" */
  if (p_struct->address) {
    free(p_struct->address);
    p_struct->address = NULL;
  }
  {
    const char *s;
    s = GWEN_DB_GetCharValue(p_db, "address", 0, NULL);
    if (s) p_struct->address = strdup(s);
  }
  if (p_struct->address == NULL) {
    p_struct->address = NULL;
  }

  /* member "port" */
  p_struct->port = GWEN_DB_GetIntValue(p_db, "port", 0, 0);

  /* member "systemId" */
  if (p_struct->systemId) {
    free(p_struct->systemId);
    p_struct->systemId = NULL;
  }
  {
    const char *s;
    s = GWEN_DB_GetCharValue(p_db, "systemId", 0, NULL);
    if (s) p_struct->systemId = strdup(s);
  }
  if (p_struct->systemId == NULL) {
    p_struct->systemId = NULL;
  }

}

int GWEN_Crypt_Token_Context_WriteDb(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct, GWEN_DB_NODE *p_db)
{
  int p_rv;

  assert(p_struct);
  /* member "id" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "id", p_struct->id);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "signKeyId" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "signKeyId", p_struct->signKeyId);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "verifyKeyId" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "verifyKeyId", p_struct->verifyKeyId);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "encipherKeyId" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "encipherKeyId", p_struct->encipherKeyId);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "decipherKeyId" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "decipherKeyId", p_struct->decipherKeyId);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "authSignKeyId" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "authSignKeyId", p_struct->authSignKeyId);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "authVerifyKeyId" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "authVerifyKeyId", p_struct->authVerifyKeyId);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "tempSignKeyId" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "tempSignKeyId", p_struct->tempSignKeyId);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "keyHashNum" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "keyHashNum", p_struct->keyHashNum);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "keyHashVer" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "keyHashVer", p_struct->keyHashVer);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "keyHashAlgo" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "keyHashAlgo", p_struct->keyHashAlgo);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "keyHash" */
  {
    if (p_struct->keyHash.length && p_struct->keyHash.pointer) {
      GWEN_DB_SetBinValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "keyHash", p_struct->keyHash.pointer, p_struct->keyHash.length);
    } else {
      GWEN_DB_DeleteVar(p_db, "keyHash");
      p_rv = 0;
    }
  }
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "keyStatus" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "keyStatus", p_struct->keyStatus);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "protocolVersion" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "protocolVersion", p_struct->protocolVersion);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "cid" */
  if (p_struct->cid) p_rv = GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "cid", p_struct->cid);
  else {
    GWEN_DB_DeleteVar(p_db, "cid");
    p_rv = 0;
  }
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "serviceId" */
  if (p_struct->serviceId) p_rv = GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "serviceId", p_struct->serviceId);
  else {
    GWEN_DB_DeleteVar(p_db, "serviceId");
    p_rv = 0;
  }
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "userId" */
  if (p_struct->userId) p_rv = GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "userId", p_struct->userId);
  else {
    GWEN_DB_DeleteVar(p_db, "userId");
    p_rv = 0;
  }
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "customerId" */
  if (p_struct->customerId) p_rv = GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "customerId", p_struct->customerId);
  else {
    GWEN_DB_DeleteVar(p_db, "customerId");
    p_rv = 0;
  }
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "userName" */
  if (p_struct->userName) p_rv = GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "userName", p_struct->userName);
  else {
    GWEN_DB_DeleteVar(p_db, "userName");
    p_rv = 0;
  }
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "peerId" */
  if (p_struct->peerId) p_rv = GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "peerId", p_struct->peerId);
  else {
    GWEN_DB_DeleteVar(p_db, "peerId");
    p_rv = 0;
  }
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "peerName" */
  if (p_struct->peerName) p_rv = GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "peerName", p_struct->peerName);
  else {
    GWEN_DB_DeleteVar(p_db, "peerName");
    p_rv = 0;
  }
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "address" */
  if (p_struct->address) p_rv = GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "address", p_struct->address);
  else {
    GWEN_DB_DeleteVar(p_db, "address");
    p_rv = 0;
  }
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "port" */
  p_rv = GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "port", p_struct->port);
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "systemId" */
  if (p_struct->systemId) p_rv = GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "systemId", p_struct->systemId);
  else {
    GWEN_DB_DeleteVar(p_db, "systemId");
    p_rv = 0;
  }
  if (p_rv < 0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  return 0;
}

GWEN_CRYPT_TOKEN_CONTEXT *GWEN_Crypt_Token_Context_fromDb(GWEN_DB_NODE *p_db)
{
  GWEN_CRYPT_TOKEN_CONTEXT *p_struct;
  p_struct = GWEN_Crypt_Token_Context_new();
  GWEN_Crypt_Token_Context_ReadDb(p_struct, p_db);
  return p_struct;
}

int GWEN_Crypt_Token_Context_toDb(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct, GWEN_DB_NODE *p_db)
{
  return GWEN_Crypt_Token_Context_WriteDb(p_struct, p_db);
}

void GWEN_Crypt_Token_Context_ReadXml(GWEN_CRYPT_TOKEN_CONTEXT *p_struct, GWEN_XMLNODE *p_db)
{
  assert(p_struct);
  /* member "id" */
  p_struct->id = GWEN_XMLNode_GetIntValue(p_db, "id", 0);

  /* member "signKeyId" */
  p_struct->signKeyId = GWEN_XMLNode_GetIntValue(p_db, "signKeyId", 0);

  /* member "verifyKeyId" */
  p_struct->verifyKeyId = GWEN_XMLNode_GetIntValue(p_db, "verifyKeyId", 0);

  /* member "encipherKeyId" */
  p_struct->encipherKeyId = GWEN_XMLNode_GetIntValue(p_db, "encipherKeyId", 0);

  /* member "decipherKeyId" */
  p_struct->decipherKeyId = GWEN_XMLNode_GetIntValue(p_db, "decipherKeyId", 0);

  /* member "authSignKeyId" */
  p_struct->authSignKeyId = GWEN_XMLNode_GetIntValue(p_db, "authSignKeyId", 0);

  /* member "authVerifyKeyId" */
  p_struct->authVerifyKeyId = GWEN_XMLNode_GetIntValue(p_db, "authVerifyKeyId", 0);

  /* member "tempSignKeyId" */
  p_struct->tempSignKeyId = GWEN_XMLNode_GetIntValue(p_db, "tempSignKeyId", 0);

  /* member "keyHashNum" */
  p_struct->keyHashNum = GWEN_XMLNode_GetIntValue(p_db, "keyHashNum", 0);

  /* member "keyHashVer" */
  p_struct->keyHashVer = GWEN_XMLNode_GetIntValue(p_db, "keyHashVer", 0);

  /* member "keyHashAlgo" */
  p_struct->keyHashAlgo = GWEN_XMLNode_GetIntValue(p_db, "keyHashAlgo", 0);

  /* member "keyHash" */
  {
    const char *s;
    s = GWEN_XMLNode_GetCharValue(p_db, "keyHash", NULL);
    if (s) {
      GWEN_BUFFER *tbuf;
      int rv;
      tbuf = GWEN_Buffer_new(0, 1024, 0, 1);
      rv = GWEN_Base64_Decode((const unsigned char*)s, strlen(s), tbuf);
      if (rv < 0) {
        DBG_INFO(GWEN_LOGDOMAIN, "here (%d)", rv);
      } else {
        char *t;
        uint32_t len;
        len = GWEN_Buffer_GetUsedBytes(tbuf);
        t = GWEN_Buffer_GetStart(tbuf);
        if (GWEN_Buffer_Relinquish(tbuf) < 0) {
          uint8_t *dest;
          dest = (uint8_t*) malloc(len);
          memmove(dest, t, len);
          p_struct->keyHash.pointer = dest;
          p_struct->keyHash.length = len;
        } else {
          p_struct->keyHash.pointer = (uint8_t*) t;
          p_struct->keyHash.length = len;
        }
      }
      GWEN_Buffer_free(tbuf);
    }
  }

  /* member "keyStatus" */
  p_struct->keyStatus = GWEN_XMLNode_GetIntValue(p_db, "keyStatus", 0);

  /* member "protocolVersion" */
  p_struct->protocolVersion = GWEN_XMLNode_GetIntValue(p_db, "protocolVersion", 0);

  /* member "cid" */
  if (p_struct->cid) {
    free(p_struct->cid);
    p_struct->cid = NULL;
  }
  {
    const char *s;
    s = GWEN_XMLNode_GetCharValue(p_db, "cid", NULL);
    if (s) p_struct->cid = strdup(s);
  }
  if (p_struct->cid == NULL) { /* preset member "cid" if empty */
    p_struct->cid = NULL;
  }

  /* member "serviceId" */
  if (p_struct->serviceId) {
    free(p_struct->serviceId);
    p_struct->serviceId = NULL;
  }
  {
    const char *s;
    s = GWEN_XMLNode_GetCharValue(p_db, "serviceId", NULL);
    if (s) p_struct->serviceId = strdup(s);
  }
  if (p_struct->serviceId == NULL) { /* preset member "serviceId" if empty */
    p_struct->serviceId = NULL;
  }

  /* member "userId" */
  if (p_struct->userId) {
    free(p_struct->userId);
    p_struct->userId = NULL;
  }
  {
    const char *s;
    s = GWEN_XMLNode_GetCharValue(p_db, "userId", NULL);
    if (s) p_struct->userId = strdup(s);
  }
  if (p_struct->userId == NULL) { /* preset member "userId" if empty */
    p_struct->userId = NULL;
  }

  /* member "customerId" */
  if (p_struct->customerId) {
    free(p_struct->customerId);
    p_struct->customerId = NULL;
  }
  {
    const char *s;
    s = GWEN_XMLNode_GetCharValue(p_db, "customerId", NULL);
    if (s) p_struct->customerId = strdup(s);
  }
  if (p_struct->customerId == NULL) { /* preset member "customerId" if empty */
    p_struct->customerId = NULL;
  }

  /* member "userName" */
  if (p_struct->userName) {
    free(p_struct->userName);
    p_struct->userName = NULL;
  }
  {
    const char *s;
    s = GWEN_XMLNode_GetCharValue(p_db, "userName", NULL);
    if (s) p_struct->userName = strdup(s);
  }
  if (p_struct->userName == NULL) { /* preset member "userName" if empty */
    p_struct->userName = NULL;
  }

  /* member "peerId" */
  if (p_struct->peerId) {
    free(p_struct->peerId);
    p_struct->peerId = NULL;
  }
  {
    const char *s;
    s = GWEN_XMLNode_GetCharValue(p_db, "peerId", NULL);
    if (s) p_struct->peerId = strdup(s);
  }
  if (p_struct->peerId == NULL) { /* preset member "peerId" if empty */
    p_struct->peerId = NULL;
  }

  /* member "peerName" */
  if (p_struct->peerName) {
    free(p_struct->peerName);
    p_struct->peerName = NULL;
  }
  {
    const char *s;
    s = GWEN_XMLNode_GetCharValue(p_db, "peerName", NULL);
    if (s) p_struct->peerName = strdup(s);
  }
  if (p_struct->peerName == NULL) { /* preset member "peerName" if empty */
    p_struct->peerName = NULL;
  }

  /* member "address" */
  if (p_struct->address) {
    free(p_struct->address);
    p_struct->address = NULL;
  }
  {
    const char *s;
    s = GWEN_XMLNode_GetCharValue(p_db, "address", NULL);
    if (s) p_struct->address = strdup(s);
  }
  if (p_struct->address == NULL) { /* preset member "address" if empty */
    p_struct->address = NULL;
  }

  /* member "port" */
  p_struct->port = GWEN_XMLNode_GetIntValue(p_db, "port", 0);

  /* member "systemId" */
  if (p_struct->systemId) {
    free(p_struct->systemId);
    p_struct->systemId = NULL;
  }
  {
    const char *s;
    s = GWEN_XMLNode_GetCharValue(p_db, "systemId", NULL);
    if (s) p_struct->systemId = strdup(s);
  }
  if (p_struct->systemId == NULL) { /* preset member "systemId" if empty */
    p_struct->systemId = NULL;
  }

}

void GWEN_Crypt_Token_Context_WriteXml(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct, GWEN_XMLNODE *p_db)
{
  assert(p_struct);
  /* member "id" */
  GWEN_XMLNode_SetIntValue(p_db, "id", p_struct->id);

  /* member "signKeyId" */
  GWEN_XMLNode_SetIntValue(p_db, "signKeyId", p_struct->signKeyId);

  /* member "verifyKeyId" */
  GWEN_XMLNode_SetIntValue(p_db, "verifyKeyId", p_struct->verifyKeyId);

  /* member "encipherKeyId" */
  GWEN_XMLNode_SetIntValue(p_db, "encipherKeyId", p_struct->encipherKeyId);

  /* member "decipherKeyId" */
  GWEN_XMLNode_SetIntValue(p_db, "decipherKeyId", p_struct->decipherKeyId);

  /* member "authSignKeyId" */
  GWEN_XMLNode_SetIntValue(p_db, "authSignKeyId", p_struct->authSignKeyId);

  /* member "authVerifyKeyId" */
  GWEN_XMLNode_SetIntValue(p_db, "authVerifyKeyId", p_struct->authVerifyKeyId);

  /* member "tempSignKeyId" */
  GWEN_XMLNode_SetIntValue(p_db, "tempSignKeyId", p_struct->tempSignKeyId);

  /* member "keyHashNum" */
  GWEN_XMLNode_SetIntValue(p_db, "keyHashNum", p_struct->keyHashNum);

  /* member "keyHashVer" */
  GWEN_XMLNode_SetIntValue(p_db, "keyHashVer", p_struct->keyHashVer);

  /* member "keyHashAlgo" */
  GWEN_XMLNode_SetIntValue(p_db, "keyHashAlgo", p_struct->keyHashAlgo);

  /* member "keyHash" */
  {
    if (p_struct->keyHash.length && p_struct->keyHash.pointer) {
      GWEN_BUFFER *tbuf;
      int rv;
      tbuf = GWEN_Buffer_new(0, 1024, 0, 1);
      rv = GWEN_Base64_Encode((const unsigned char*) p_struct->keyHash.pointer, p_struct->keyHash.length, tbuf, 80);
      if (rv < 0) {
        DBG_INFO(GWEN_LOGDOMAIN, "here (%d)", rv);
      } else {
        GWEN_XMLNode_SetCharValue(p_db, "keyHash", GWEN_Buffer_GetStart(tbuf));
        GWEN_Buffer_free(tbuf);
      }
    }
  }

  /* member "keyStatus" */
  GWEN_XMLNode_SetIntValue(p_db, "keyStatus", p_struct->keyStatus);

  /* member "protocolVersion" */
  GWEN_XMLNode_SetIntValue(p_db, "protocolVersion", p_struct->protocolVersion);

  /* member "cid" */
  GWEN_XMLNode_SetCharValue(p_db, "cid", p_struct->cid);

  /* member "serviceId" */
  GWEN_XMLNode_SetCharValue(p_db, "serviceId", p_struct->serviceId);

  /* member "userId" */
  GWEN_XMLNode_SetCharValue(p_db, "userId", p_struct->userId);

  /* member "customerId" */
  GWEN_XMLNode_SetCharValue(p_db, "customerId", p_struct->customerId);

  /* member "userName" */
  GWEN_XMLNode_SetCharValue(p_db, "userName", p_struct->userName);

  /* member "peerId" */
  GWEN_XMLNode_SetCharValue(p_db, "peerId", p_struct->peerId);

  /* member "peerName" */
  GWEN_XMLNode_SetCharValue(p_db, "peerName", p_struct->peerName);

  /* member "address" */
  GWEN_XMLNode_SetCharValue(p_db, "address", p_struct->address);

  /* member "port" */
  GWEN_XMLNode_SetIntValue(p_db, "port", p_struct->port);

  /* member "systemId" */
  GWEN_XMLNode_SetCharValue(p_db, "systemId", p_struct->systemId);

}

void GWEN_Crypt_Token_Context_toXml(const GWEN_CRYPT_TOKEN_CONTEXT *p_struct, GWEN_XMLNODE *p_db)
{
  GWEN_Crypt_Token_Context_WriteXml(p_struct, p_db);
}

GWEN_CRYPT_TOKEN_CONTEXT *GWEN_Crypt_Token_Context_fromXml(GWEN_XMLNODE *p_db)
{
  GWEN_CRYPT_TOKEN_CONTEXT *p_struct;
  p_struct = GWEN_Crypt_Token_Context_new();
  GWEN_Crypt_Token_Context_ReadXml(p_struct, p_db);
  return p_struct;
}

GWEN_CRYPT_TOKEN_CONTEXT *GWEN_Crypt_Token_Context_List_GetById(const GWEN_CRYPT_TOKEN_CONTEXT_LIST *p_list, uint32_t p_cmp)
{
  GWEN_CRYPT_TOKEN_CONTEXT *p_struct;

  assert(p_list);
  p_struct = GWEN_Crypt_Token_Context_List_First(p_list);
  while(p_struct) {
    int p_rv;

    if (p_struct->id == p_cmp) p_rv = 0;
    else if (p_cmp < p_struct->id) p_rv = -1;
    else p_rv = 1;
    if (p_rv == 0)
      return p_struct;
    p_struct = GWEN_Crypt_Token_Context_List_Next(p_struct);
  }
  return NULL;
}

void GWEN_Crypt_Token_Context_SetKeyHash(GWEN_CRYPT_TOKEN_CONTEXT *st, const uint8_t *p, uint32_t len)
{
  assert(st);
  if (st->keyHash.length && st->keyHash.pointer) free(st->keyHash.pointer);
  if (p && len) {
    st->keyHash.pointer = (uint8_t*) malloc(len);
    if (st->keyHash.pointer) {
      st->keyHash.length = len;
      memmove(st->keyHash.pointer, p, len);
    } else {
      st->keyHash.pointer = NULL;
      st->keyHash.length = 0;
    }
  } else {
    st->keyHash.length = 0;
    st->keyHash.pointer = NULL;
  }
}
const uint8_t* GWEN_Crypt_Token_Context_GetKeyHashPtr(const GWEN_CRYPT_TOKEN_CONTEXT *st)
{
  assert(st);
  return st->keyHash.pointer;
}
uint32_t GWEN_Crypt_Token_Context_GetKeyHashLen(const GWEN_CRYPT_TOKEN_CONTEXT *st)
{
  assert(st);
  return st->keyHash.length;
}

/* code headers */

